{
    "version": 3,
    "file": "generated.js",
    "sources": [
        "tmp/scripts/main.js",
        "tmp/scripts/utils.js",
        "tmp/scripts/board.js",
        "/insert-module-globals/node_modules/process/browser.js",
        "/browser-builtins/builtin/path.js"
    ],
    "names": [],
    "mappings": ";AAAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
    "sourcesContent": [
        "// Generated by CoffeeScript 1.6.3\nrequire(\"./utils\");\n\nrequire(\"./board\");\n",
        "// Generated by CoffeeScript 1.6.3\nvar utils;\n\nutils = exports;\n\nutils.padLeft = function(string, width, pad) {\n  string = \"\" + string;\n  while (string.length < width) {\n    string = pad + string;\n  }\n  return string;\n};\n",
        "// Generated by CoffeeScript 1.6.3\nvar BOARD_HEIGHT, BOARD_IMAGE, BOARD_WIDTH, CRATERS, HEX_COLS, HEX_HEIGHT, HEX_OFFSET_X, HEX_OFFSET_Y, HEX_ROWS, HEX_WIDTH, IMAGE_URL, PIECE_IMAGES, RUBBLE, board, buildEdges, buildHexes, buildPieceImages, directions, getHexName, main, path, utils;\n\nIMAGE_URL = \"vendor/vassal/images\";\n\nBOARD_IMAGE = \"\" + IMAGE_URL + \"/ogre-map.png\";\n\nBOARD_WIDTH = 900;\n\nBOARD_HEIGHT = 1542;\n\nHEX_COLS = 15;\n\nHEX_ROWS = 22;\n\nHEX_WIDTH = 70;\n\nHEX_HEIGHT = 60;\n\nHEX_OFFSET_X = 36;\n\nHEX_OFFSET_Y = 101;\n\nCRATERS = [\"0304\"];\n\nRUBBLE = [[\"0103\", \"0203\"], [\"0104\", \"0203\"]];\n\nPIECE_IMAGES = {\n  cp_alpha: \"cp-alpha\",\n  gev: \"gev\",\n  hvy_tank: \"hvy-tank\",\n  hwz: \"hwz\",\n  infantry_1: \"infantry-1\",\n  infantry_2: \"infantry-2\",\n  infantry_3: \"infantry-3\",\n  msl_tank: \"msl-tank\",\n  ogre_mk3: \"ogre-mk3\",\n  ogre_mk5: \"ogre-mk5\"\n};\n\npath = require(\"path\");\n\nutils = require(\"./utils\");\n\nboard = exports;\n\nmain = function() {\n  board.image = BOARD_IMAGE;\n  buildHexes();\n  buildEdges();\n  buildPieceImages();\n};\n\nbuildHexes = function() {\n  var col, name, odd, row, x, xIncrement, xOffset, y, yIncrement, yOffset, yOffsetEven, yOffsetOdd, _i, _j;\n  board.hexes = {};\n  yOffsetOdd = HEX_OFFSET_Y;\n  yOffsetEven = HEX_OFFSET_Y - HEX_HEIGHT / 2;\n  xIncrement = HEX_WIDTH * 3 / 4;\n  yIncrement = HEX_HEIGHT;\n  for (col = _i = 1; 1 <= HEX_COLS ? _i < HEX_COLS : _i > HEX_COLS; col = 1 <= HEX_COLS ? ++_i : --_i) {\n    for (row = _j = 1; 1 <= HEX_ROWS ? _j < HEX_ROWS : _j > HEX_ROWS; row = 1 <= HEX_ROWS ? ++_j : --_j) {\n      odd = !!(col % 2);\n      if (odd && (row === 1)) {\n        continue;\n      }\n      xOffset = HEX_OFFSET_X;\n      if (odd) {\n        yOffset = HEX_OFFSET_Y;\n      }\n      if (!odd) {\n        yOffset = HEX_OFFSET_Y - HEX_HEIGHT / 2;\n      }\n      x = xOffset + xIncrement * (row - 1);\n      y = yOffset + yIncrement * (col - 1);\n      name = getHexName(col, row);\n      board.hexes[name] = {\n        name: name,\n        row: row,\n        col: col,\n        x: x,\n        y: y\n      };\n    }\n  }\n};\n\nbuildPieceImages = function() {\n  var file, name;\n  board.pieceImages = {\n    b: {},\n    w: {}\n  };\n  for (name in PIECE_IMAGES) {\n    file = PIECE_IMAGES[name];\n    file = \"\" + IMAGE_URL + \"/\" + file;\n    board.pieceImages.b[name] = \"\" + file + \"-b.png\";\n    board.pieceImages.w[name] = \"\" + file + \"-w.png\";\n  }\n};\n\ndirections = {\n  0: [0, -1],\n  1: [1, 0],\n  2: [1, 1],\n  3: [0, 1],\n  4: [-1, 0],\n  5: [-1, -1]\n};\n\nbuildEdges = function() {\n  var cCol, cHex, cName, cRow, crater, dirName, dirOffset, edge, hex, hex1, hex2, name, odd, rubble, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;\n  _ref = board.hexes;\n  for (name in _ref) {\n    hex = _ref[name];\n    hex.edges = {};\n    odd = !!(hex.col % 2);\n    for (dirName in directions) {\n      dirOffset = directions[dirName];\n      cCol = hex.col + dirOffset[0];\n      cRow = hex.row + dirOffset[1];\n      cName = getHexName(cCol, cRow);\n      if (!board.hexes[cName]) {\n        continue;\n      }\n      hex.edges[cName] = {\n        hex: hex\n      };\n    }\n  }\n  for (_i = 0, _len = CRATERS.length; _i < _len; _i++) {\n    crater = CRATERS[_i];\n    hex = board.hexes[crater];\n    _ref1 = hex.edges;\n    for (edge = _j = 0, _len1 = _ref1.length; _j < _len1; edge = ++_j) {\n      cName = _ref1[edge];\n      cHex = board.hexes[cName];\n      cHex.edges[hex.name].isCrater = true;\n    }\n  }\n  for (_k = 0, _len2 = RUBBLE.length; _k < _len2; _k++) {\n    rubble = RUBBLE[_k];\n    hex1 = board.hexes[rubble[0]];\n    hex2 = board.hexes[rubble[1]];\n    hex1.edges[hex2.name].isRubble = true;\n    hex2.edges[hex1.name].isRubble = true;\n  }\n};\n\ngetHexName = function(col, row) {\n  return utils.padLeft(col, 2, \"0\") + utils.padLeft(row, 2, \"0\");\n};\n\nmain();\n",
        "// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n",
        "var process=require(\"__browserify_process\");function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\n"
    ]
}