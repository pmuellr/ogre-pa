;(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
require("./utils");

require("./board");

},{"./board":3,"./utils":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var utils;

utils = exports;

utils.padLeft = function(string, width, pad) {
  string = "" + string;
  while (string.length < width) {
    string = pad + string;
  }
  return string;
};

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.3
var BOARD_HEIGHT, BOARD_IMAGE, BOARD_WIDTH, CRATERS, HEX_COLS, HEX_HEIGHT, HEX_OFFSET_X, HEX_OFFSET_Y, HEX_ROWS, HEX_WIDTH, IMAGE_URL, PIECE_IMAGES, RUBBLE, board, buildEdges, buildHexes, buildPieceImages, directions, getHexName, main, path, utils;

IMAGE_URL = "vendor/vassal/images";

BOARD_IMAGE = "" + IMAGE_URL + "/ogre-map.png";

BOARD_WIDTH = 900;

BOARD_HEIGHT = 1542;

HEX_COLS = 15;

HEX_ROWS = 22;

HEX_WIDTH = 70;

HEX_HEIGHT = 60;

HEX_OFFSET_X = 36;

HEX_OFFSET_Y = 101;

CRATERS = ["0304"];

RUBBLE = [["0103", "0203"], ["0104", "0203"]];

PIECE_IMAGES = {
  cp_alpha: "cp-alpha",
  gev: "gev",
  hvy_tank: "hvy-tank",
  hwz: "hwz",
  infantry_1: "infantry-1",
  infantry_2: "infantry-2",
  infantry_3: "infantry-3",
  msl_tank: "msl-tank",
  ogre_mk3: "ogre-mk3",
  ogre_mk5: "ogre-mk5"
};

path = require("path");

utils = require("./utils");

board = exports;

main = function() {
  board.image = BOARD_IMAGE;
  buildHexes();
  buildEdges();
  buildPieceImages();
};

buildHexes = function() {
  var col, name, odd, row, x, xIncrement, xOffset, y, yIncrement, yOffset, yOffsetEven, yOffsetOdd, _i, _j;
  board.hexes = {};
  yOffsetOdd = HEX_OFFSET_Y;
  yOffsetEven = HEX_OFFSET_Y - HEX_HEIGHT / 2;
  xIncrement = HEX_WIDTH * 3 / 4;
  yIncrement = HEX_HEIGHT;
  for (col = _i = 1; 1 <= HEX_COLS ? _i < HEX_COLS : _i > HEX_COLS; col = 1 <= HEX_COLS ? ++_i : --_i) {
    for (row = _j = 1; 1 <= HEX_ROWS ? _j < HEX_ROWS : _j > HEX_ROWS; row = 1 <= HEX_ROWS ? ++_j : --_j) {
      odd = !!(col % 2);
      if (odd && (row === 1)) {
        continue;
      }
      xOffset = HEX_OFFSET_X;
      if (odd) {
        yOffset = HEX_OFFSET_Y;
      }
      if (!odd) {
        yOffset = HEX_OFFSET_Y - HEX_HEIGHT / 2;
      }
      x = xOffset + xIncrement * (row - 1);
      y = yOffset + yIncrement * (col - 1);
      name = getHexName(col, row);
      board.hexes[name] = {
        name: name,
        row: row,
        col: col,
        x: x,
        y: y
      };
    }
  }
};

buildPieceImages = function() {
  var file, name;
  board.pieceImages = {
    b: {},
    w: {}
  };
  for (name in PIECE_IMAGES) {
    file = PIECE_IMAGES[name];
    file = "" + IMAGE_URL + "/" + file;
    board.pieceImages.b[name] = "" + file + "-b.png";
    board.pieceImages.w[name] = "" + file + "-w.png";
  }
};

directions = {
  0: [0, -1],
  1: [1, 0],
  2: [1, 1],
  3: [0, 1],
  4: [-1, 0],
  5: [-1, -1]
};

buildEdges = function() {
  var cCol, cHex, cName, cRow, crater, dirName, dirOffset, edge, hex, hex1, hex2, name, odd, rubble, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
  _ref = board.hexes;
  for (name in _ref) {
    hex = _ref[name];
    hex.edges = {};
    odd = !!(hex.col % 2);
    for (dirName in directions) {
      dirOffset = directions[dirName];
      cCol = hex.col + dirOffset[0];
      cRow = hex.row + dirOffset[1];
      cName = getHexName(cCol, cRow);
      if (!board.hexes[cName]) {
        continue;
      }
      hex.edges[cName] = {
        hex: hex
      };
    }
  }
  for (_i = 0, _len = CRATERS.length; _i < _len; _i++) {
    crater = CRATERS[_i];
    hex = board.hexes[crater];
    _ref1 = hex.edges;
    for (edge = _j = 0, _len1 = _ref1.length; _j < _len1; edge = ++_j) {
      cName = _ref1[edge];
      cHex = board.hexes[cName];
      cHex.edges[hex.name].isCrater = true;
    }
  }
  for (_k = 0, _len2 = RUBBLE.length; _k < _len2; _k++) {
    rubble = RUBBLE[_k];
    hex1 = board.hexes[rubble[0]];
    hex2 = board.hexes[rubble[1]];
    hex1.edges[hex2.name].isRubble = true;
    hex2.edges[hex1.name].isRubble = true;
  }
};

getHexName = function(col, row) {
  return utils.padLeft(col, 2, "0") + utils.padLeft(row, 2, "0");
};

main();

},{"./utils":2,"path":4}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],4:[function(require,module,exports){
var process=require("__browserify_process");function filter (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (fn(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length; i >= 0; i--) {
    var last = parts[i];
    if (last == '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Regex to split a filename into [*, dir, basename, ext]
// posix version
var splitPathRe = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/;

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
var resolvedPath = '',
    resolvedAbsolute = false;

for (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {
  var path = (i >= 0)
      ? arguments[i]
      : process.cwd();

  // Skip empty and invalid entries
  if (typeof path !== 'string' || !path) {
    continue;
  }

  resolvedPath = path + '/' + resolvedPath;
  resolvedAbsolute = path.charAt(0) === '/';
}

// At this point the path should be resolved to a full absolute path, but
// handle relative paths to be safe (might happen when process.cwd() fails)

// Normalize the path
resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
var isAbsolute = path.charAt(0) === '/',
    trailingSlash = path.slice(-1) === '/';

// Normalize the path
path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }
  
  return (isAbsolute ? '/' : '') + path;
};


// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    return p && typeof p === 'string';
  }).join('/'));
};


exports.dirname = function(path) {
  var dir = splitPathRe.exec(path)[1] || '';
  var isWindows = false;
  if (!dir) {
    // No dirname
    return '.';
  } else if (dir.length === 1 ||
      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {
    // It is just a slash or a drive letter with a slash
    return dir;
  } else {
    // It is a full dirname, strip trailing slash
    return dir.substring(0, dir.length - 1);
  }
};


exports.basename = function(path, ext) {
  var f = splitPathRe.exec(path)[2] || '';
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPathRe.exec(path)[3] || '';
};

exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';

},{"__browserify_process":5}]},{},[1])
//@ sourceMappingURL=ogre-pa.js.map
;